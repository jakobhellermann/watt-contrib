static WASM: &[u8] = include_bytes!("ctor.wasm");
static MACRO: watt::WasmMacro = watt::WasmMacro::new(WASM);
#[doc = " Marks a function or static variable as a library/executable constructor."]
#[doc = " This uses OS-specific linker sections to call a specific function at"]
#[doc = " load time."]
#[doc = ""]
#[doc = " Multiple startup functions/statics are supported, but the invocation order is not"]
#[doc = " guaranteed."]
#[doc = ""]
#[doc = " # Examples"]
#[doc = ""]
#[doc = " Print a startup message:"]
#[doc = ""]
#[doc = " ```rust"]
#[doc = " # extern crate ctor;"]
#[doc = " # use ctor::*;"]
#[doc = " #[ctor]"]
#[doc = " fn foo() {"]
#[doc = "   println!(\"Hello, world!\");"]
#[doc = " }"]
#[doc = ""]
#[doc = " # fn main() {"]
#[doc = " println!(\"main()\");"]
#[doc = " # }"]
#[doc = " ```"]
#[doc = ""]
#[doc = " Make changes to `static` variables:"]
#[doc = ""]
#[doc = " ```rust"]
#[doc = " # extern crate ctor;"]
#[doc = " # use ctor::*;"]
#[doc = " # use std::sync::atomic::{AtomicBool, Ordering};"]
#[doc = " static INITED: AtomicBool = AtomicBool::new(false);"]
#[doc = ""]
#[doc = " #[ctor]"]
#[doc = " fn foo() {"]
#[doc = "   INITED.store(true, Ordering::SeqCst);"]
#[doc = " }"]
#[doc = " ```"]
#[doc = ""]
#[doc = " Initialize a `HashMap` at startup time:"]
#[doc = ""]
#[doc = " ```rust"]
#[doc = " # extern crate ctor;"]
#[doc = " # use std::collections::HashMap;"]
#[doc = " # use ctor::*;"]
#[doc = " #[ctor]"]
#[doc = " static STATIC_CTOR: HashMap<u32, String> = {"]
#[doc = "   let mut m = HashMap::new();"]
#[doc = "   for i in 0..100 {"]
#[doc = "     m.insert(i, format!(\"x*100={}\", i*100));"]
#[doc = "   }"]
#[doc = "   m"]
#[doc = " };"]
#[doc = ""]
#[doc = " # pub fn main() {"]
#[doc = " #   assert_eq!(STATIC_CTOR.len(), 100);"]
#[doc = " #   assert_eq!(STATIC_CTOR[&20], \"x*100=2000\");"]
#[doc = " # }"]
#[doc = " ```"]
#[doc = ""]
#[doc = " # Details"]
#[doc = ""]
#[doc = " The `#[ctor]` macro makes use of linker sections to ensure that a"]
#[doc = " function is run at startup time."]
#[doc = ""]
#[doc = " The above example translates into the following Rust code (approximately):"]
#[doc = ""]
#[doc = "```rust"]
#[doc = " #[used]"]
#[doc = " #[cfg_attr(any(target_os = \"linux\", target_os = \"android\"), link_section = \".init_array\")]"]
#[doc = " #[cfg_attr(target_os = \"freebsd\", link_section = \".init_array\")]"]
#[doc = " #[cfg_attr(any(target_os = \"macos\", target_os = \"ios\"), link_section = \"__DATA,__mod_init_func\")]"]
#[doc = " #[cfg_attr(target_os = \"windows\", link_section = \".CRT$XCU\")]"]
#[doc = " static FOO: extern fn() = {"]
#[doc = "   #[cfg_attr(any(target_os = \"linux\", target_os = \"android\"), link_section = \".text.startup\")]"]
#[doc = "   extern fn foo() { /* ... */ };"]
#[doc = "   foo"]
#[doc = " };"]
#[doc = " ```"]
#[proc_macro_attribute]
pub fn ctor(
    args: proc_macro::TokenStream,
    input: proc_macro::TokenStream,
) -> proc_macro::TokenStream {
    MACRO.proc_macro_attribute(stringify!(ctor), args, input)
}
#[doc = " Marks a function as a library/executable destructor. This uses OS-specific"]
#[doc = " linker sections to call a specific function at termination time."]
#[doc = ""]
#[doc = " Multiple shutdown functions are supported, but the invocation order is not"]
#[doc = " guaranteed."]
#[doc = ""]
#[doc = " `sys_common::at_exit` is usually a better solution for shutdown handling, as"]
#[doc = " it allows you to use `stdout` in your handlers."]
#[doc = ""]
#[doc = " ```rust"]
#[doc = " # extern crate ctor;"]
#[doc = " # use ctor::*;"]
#[doc = ""]
#[doc = " #[dtor]"]
#[doc = " fn shutdown() {"]
#[doc = "   /* ... */"]
#[doc = " }"]
#[doc = " ```"]
#[proc_macro_attribute]
pub fn dtor(
    args: proc_macro::TokenStream,
    input: proc_macro::TokenStream,
) -> proc_macro::TokenStream {
    MACRO.proc_macro_attribute(stringify!(dtor), args, input)
}
